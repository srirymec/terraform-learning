
Terraform init 
• Check the config file and initializes the working directory containing the .tf 
• Initialize the providers mentioned 
• Making use the plugins, downloads the plugin and install it (example - local plugin or aws plugins) 
• Terraform plugins are downloaded in ${working_directory}/.terraform/plugins/ 
• The command can be run as many times as needed. 
 
Local_file provider example: 
 
Main.tf 
Resource "local_file" "pet"{ 
    filename = "/var/tmp/pets.txt" 
    content = "we love pets" 
} 
 
We can have multiple providers in the same configuration file. 
 
Local with random provider 
Resource "local_file" "pet"{ 
    filename = "/var/tmp/pets.txt" 
    content = "we love pets" 
} 
 
Resource "random_pet" "mypet"{ 
} 
 
Providers with version constraints: 
 
We can specify the providers with version constraints, 
 
Terraform { 
    required_providers { 
         local = { 
             source = "hashicorp/local" 
             version = "1.4.0" ("!=2.0.0" | "< 1.4.0" | "> 1.1.0" | "> 1.2.0, < 2.0.0, != 1.4.0"| "~> 1.2") 
         } 
    } 
} 
 
Terraform show 
• Displays the configuration created by running the terraform show command 
• This command inspects the state file and display the resource created 
 
Terraform plan 
• Creates the plan of infrastructure to be created from the tf files 
• Output to the .plan file 
• Terraform refresh=false --> do not refresh the state. Just go with the config details in tfstate file. 
 
Terraform apply 
• Apply the plan 
 
Any change in the tf file after the infra is created, the resource will be force replaces (forces replacement) 
 
Tf files: 
• Main.tf: main configuration file containing resource definition 
• Variables.tf: contains variable declaration 
• Outputs.tf: contains outputs from resources 
• Provider.tf: contains provider information. 
 
Variables in terraform: 
 
Defined in variables.tf 
 
Variables.tf 
Variable "prefix" { 
     default = ["Mr", "Mrs", "Sir"] 
      type = list 
} 
 
Variable "length" { 
     default = 2 
     type = number 
     description = "" 
} 
 
Main.tf 
Resource "random_pet" "mypet"{ 
     prefix = var.prefix[0] 
     length = var.length 
} 
 
Supported types: 
 
string 
Number 
Bool 
Any 
List 
Map 
Object 
tuple 
 
 
If you want to use the output generated by one resource as input to other: 
 
${random_pet.mypet.id} ---> Since random_pet returns the id of the pet created. 
 
Resource dependencies: 
 
Depends_on = [] 
 
Output variables: 
 
Output pet-name { 
     value = random_pet.mypet.id 
     description = "record the value of random_pet generated" 
} 
 
• After terraform apply, the output variables with value is printed on the console. 
• We can also see the output variables list with values using, 
Terraform output 
 
Terraform state: 
 
• The state file created only after the apply is run atleast once. 
• since the state file contains the sensitive date, store it in secured locations - like S3. 
 
Terraform commands 
 
• Terraform validate - validates the configuration 
• Terraform fmt - format the code 
• Terraform show --json 
• Terraform providers 
• Terraform output 
• Terraform refresh --> update the state file 
• Terraform graph 
• Shows the graphical representation of the resources created 
• Install graph (apt-get install graphviz -y) 
• Terraform graph | dot -Tsvg > graph.svg 
 
 
Terraform life cycle management: 
 
Create_before_destroy: if set to true, new resource to be created first, then older one to be deleted. 
 
Resource "local_file" "pet"{ 
    filename = "/var/tmp/pets.txt" 
    content = "we love pets" 
 
    lifecycle { 
        create_before_destroy = true 
    } 
} 
 
Prevent_destroy: prevents resource deletion when config is changed and terraform apply is run. 
The resource can still be deleted if terraform destroy is used. 
 
Resource "local_file" "pet"{ 
    filename = "/var/tmp/pets.txt" 
    content = "we love pets" 
 
    lifecycle { 
        prevent_destroy = true 
    } 
} 
 
Ignore_changes: accepts a list of valid attributes in the resource to ignore the changes made outside terraform (manually or cli) 
 
Resource "aws_instance" "webserver" { 
     ami = "ami---" 
     instance_type = "t2.micro" 
     tags = { 
           Name = "ProjectA-webserver" 
     } 
 
 
    lifecycle { 
        ignore_changes = [ tags/all ] 
    } 
 
} 
 
 
Data Source: 
 
Manage files created outside terraform. 
Use keyword data 
 
Resource "local_file" "pet"{ 
    filename = "/var/tmp/pets.txt" 
    content = "we love pets" 
} 
 
Data "local_file" "dog" { 
    filename = "/var/tmp/dogs.txt" 
} 
 
Here dogs.txt was created outside terraform using shell script. To manage it using terraform we use data source with keyword data. The dogs.txt will now be managed in the tfstate file. 
 
Resource vs Datasource: 
Resource 	Datasource 
Keyword: resource 	Keyword: data 
Creates, updates, destroys infra 	Only reads infra 
Also called managed resources 	Also called data resources 
 
 
Remote state and state locking: 
 
If we have the state file locally, other users who work in the code will not have the latest state file with them which may cause conflicts. It's not good either to have the state file in git repo as git does not provide state locking, also every time user may not git pull, that means the users may not have the latest state file. 
 
State locking is very important to avoid concurrency. Two users working on same code if the state is not locked, may lead to conflicts. 
 
 
Terraform backend to specify the remote state location: 
 
Terraform{ 
    backend "s3" { 
         bucket = "<bucket-name>" 
         key       = "<dir-name>" 
         region  = "us-east-1" 
         dynamodb_table = "state-locking" 
    } 
} 
 
Manipulating terraform state: 
 
This operation is strictly restricted. Do not use unless no other option. 
 
Terraform state show aws_s3_bucket.finance 
 
Other subcommands: 
 
List 
Mv 
Rm 
Pull 
show 
 
 
Terraform taint: 
 
If you want to have the resource re-created, taint the resource. By tainting the resource, terraform will re-create the resource in the next apply. 
 
To undo a taint, use untaint 
 
Terraform logging: 
 
To save the logs generated with apply command, use env variable TF_LOG_PATH. 
 
Export TF_LOG_PATH=/tmp/terraform.log   ----> all the logs will be written to this file. To disable loggin, 
 
Unset TF_LOG_PATH 
 
Terraform import: 
 
For the unmanaged resource of terraform (created outside terraform), we can use datasource . But this will still not have complete control on the resource. Like we cannot delete or update the resource. We need to use terraform import. 
 
Terraform import <resource_type>.<resource_name> <attribute> 
 
Terraform import aws_instance.webserver-2 i-xxxxxxxxxxxxxxxxxx 
 
Error: Resource address "aws_instance.webserver-2" does not exist in the configuration. 
 
Before importing it, we need to add a dummy resource in our configuration first. 
 
Dummy resource block: 
Resource "aws_instance" "webserver-2" { 
} 
 
Terraform import aws_instance.webserver-2 i-xxxxxxxxxxxxxxxxxx 
Import will be successful now. 
 
Now inspect the management console or the state file to add the attributes in the configuration file. 
 
 
Terraform for-each: 
 
Variables.tf 
variable "users" { 
    type = set(string) 
} 
variable "content" { 
    default = "password: S3cr3tP@ssw0rd" 
   
} 
 
Main.tf 
resource "local_file" "name" { 
    filename = each.value 
    sensitive_content = var.content 
    for_each var.users 
} 
 
 
Terraform functions: 
 
Toset(); Converts list to set - removes duplicates 
Max() 
Min() 
Ciel() - rounds the decimal to highest (ciel(10.1) = 11) 
Floor() - rounds the decimal to lowest (floor(10.9) = 10) 
 
Split(seperator,string) 
Lower() 
Upper() 
Title() --> convert first string to upper 
Substr() -->  
Join(seperator,list) 
Length() -->  
Index() 
Element() 
Contains() 
 
Conditional expressions: 
 
&& -> both should be true - result is true 
||   -> either should be true - result is true 
!      -> Not operator 
 
Ifelse: 
If <> 
   then 
      <> 
   else 
      <> 
fi 
 
Conditional operator: 
Condition ? <true_val> : <false_val> 
 
Terraform workspaces: 
 
 
 
 
How to migrate tfstate files: 
------------------------------------- 
 
OK, I think I figured out how to do this (or at least, these steps seemed to work): 
• rename the current folder with the .tf files to something else (like folder.old) 
• use "terraform state pull" to get a local copy of the state for the current workspace (you need to repeat these steps for each workspace you want to migrate) 
• create a new folder with the original name and copy your code to it. 
• create a new workspace with the same name as the original. 
• modify the code for the remote backend to point to the new container (or whatever else you're changing about the name/location of the remote state). 
• run "terraform init" so it's pointing to the new remote backend. 
• use "terraform state push local state file" to push the exported state to the new backend. 
I then used "terraform state list" and "terraform plan" in the new folder to sanity check that everything seemed to be there. 
 
 
 
terraform { 
  backend "s3" { 
    bucket         = "srinitfstate493976-1" 
    key            = "vpc.terraform.tfstate" 
    region         = "us-east-1" 
    dynamodb_table = "srinitfstate" 
  } 
} 
 
Changed the backend config and run terraform init 
 
[root@ip-172-31-51-130 tfscripts]# terraform init 
Initializing modules... 
 
Initializing the backend... 
╷ 
│ Error: Backend configuration changed 
│ 
│ A change in the backend configuration has been detected, which may require migrating existing state. 
│ 
│ If you wish to attempt automatic migration of the state, use "terraform init -migrate-state". 
│ If you wish to store the current configuration with no changes to the state, use "terraform init -reconfigure". 
╵ 
 
[root@ip-172-31-51-130 tfscripts]#terraform init -migrate-state 
 
Will automatically move the state file from prev backend to current backend 
 
 
How to delete a specific vm created in a resource group having other vms? (Resource_type.name) 
How to delete 3rd server only in the list of 5 servers created? 
 
Creating 5 servers with different instance types - foreach and count -  
https://github.com/AKSarav/Terraform-Count-ForEach 
 
Sample terraform example for AWS foundation setup -  
https://github.com/fpco/terraform-aws-foundation 
https://registry.terraform.io/modules/fpco/foundation/aws/latest/examples/cloud-dev-workspace 
 
Multiple subnets example: 
 
https://developer.hashicorp.com/terraform/language/functions/flatten#flattening-nested-structures-for-for_each 

Terraform Commands:

Ø Terraform init
Ø Terraform plan --var-file=variable.tfvars -out=planoutput.txt
Ø Terrafrom apply planoutput.txt

Ø Terraform destroy --var-file=variables.tfvars -target=module.ec2.aws_instance.my_ec2

----- module.ec2.aws_instance.my_ec2
 module.ec2_new.aws_instance.my_ec2------


Ø terraform import <resource_type>.<resource_name> <resource_id>

terraform import --var-file=variables.tfvars module.ec2.aws_instance.my_ec2 i-06c7ad72c76dd039f
module.ec2.aws_instance.my_ec2: Importing from ID "i-06c7ad72c76dd039f"...
module.ec2.aws_instance.my_ec2: Import prepared!
  Prepared aws_instance for import
module.ec2.aws_instance.my_ec2: Refreshing state... [id=i-06c7ad72c76dd039f]

Import successful!

The resources that were imported are shown above. These resources are now in
your Terraform state and will henceforth be managed by Terraform.

srinigps@BDC7-L-332CY3C:~/GPS/terraform/client$

Ø terraform taint <resource_type>.<resource_name>

srinigps@BDC7-L-332CY3C:~/GPS/terraform/client$ terraform taint module.ec2_new.aws_instance.my_ec2
Resource instance module.ec2_new.aws_instance.my_ec2 has been marked as tainted.


If you see the terraform show, the resource is marked as tainted.


# module.ec2_new.aws_instance.my_ec2: (tainted)
resource "aws_instance" "my_ec2" {
    ami                                  = "ami-00264e664c8ba2d93"
    arn                                  = "arn:aws:ec2:us-east-1:624737702922:instance/i-0857af151ac22c689"
    associate_public_ip_address          = false
    availability_zone                    = "us-east-1b"
    cpu_core_count                       = 1
    cpu_threads_per_core                 = 1
    disable_api_stop                     = false
    disable_api_termination              = false
    ebs_optimized                        = false
    get_password_data                    = false
    hibernation                          = false
    id                                   = "i-0857af151ac22c689"
    instance_initiated_shutdown_behavior = "stop"
    instance_state                       = "running"
    instance_type                        = "t2.micro"
    ipv6_address_count                   = 0
    ipv6_addresses                       = []
    monitoring                           = false
    placement_partition_number           = 0
    primary_network_interface_id         = "eni-0cd829ca91e7bcac2"
    private_dns                          = "ip-10-0-91-185.ec2.internal"
    private_ip                           = "10.0.91.185"
    secondary_private_ips                = []
    security_groups                      = []
    source_dest_check                    = true
    subnet_id                            = "subnet-0cb071fd87f44aac8"
    tags                                 = {
        "Name" = "test123"
    }
    tags_all                             = {
        "Name" = "test123"
    }


So on the next terraform apply, the ec2 will be recreated,

terraform apply -lock=false --var-file=variables.tfvars

 # module.ec2.aws_instance.my_ec2 will be updated in-place
 # module.ec2_new.aws_instance.my_ec2 is tainted, so must be replaced

Plan: 1 to add, 1 to change, 1 to destroy.

Do you want to perform these actions?
  Terraform will perform the actions described above.
  Only 'yes' will be accepted to approve.

  Enter a value: yes

module.ec2_new.aws_instance.my_ec2: Destroying... [id=i-0857af151ac22c689]
module.ec2.aws_instance.my_ec2: Modifying... [id=i-044274b508042a8a1]
module.ec2.aws_instance.my_ec2: Modifications complete after 6s [id=i-044274b508042a8a1]
module.ec2_new.aws_instance.my_ec2: Still destroying... [id=i-0857af151ac22c689, 10s elapsed]
module.ec2_new.aws_instance.my_ec2: Still destroying... [id=i-0857af151ac22c689, 20s elapsed]
module.ec2_new.aws_instance.my_ec2: Still destroying... [id=i-0857af151ac22c689, 30s elapsed]
module.ec2_new.aws_instance.my_ec2: Destruction complete after 34s
module.ec2_new.aws_instance.my_ec2: Creating...
module.ec2_new.aws_instance.my_ec2: Still creating... [10s elapsed]
module.ec2_new.aws_instance.my_ec2: Creation complete after 47s [id=i-0efad534e6a62e6a2]

Apply complete! Resources: 1 added, 1 changed, 1 destroyed.


Migrating the state file from one location to another location.

Ø Move the terraform.tfstate file to required location (to s3 as example)
Ø Update the terraform backend configuration accordingly
Ø Terraform init
srinigps@BDC7-L-332CY3C:~/GPS/terraform/client$ terraform init
Initializing modules...

Initializing the backend...

Successfully configured the backend "s3"! Terraform will automatically
use this backend unless the backend configuration changes.

Initializing provider plugins...
- Reusing previous version of hashicorp/aws from the dependency lock file
- Using previously-installed hashicorp/aws v4.67.0

Terraform has been successfully initialized!

You may now begin working with Terraform. Try running "terraform plan" to see
any changes that are required for your infrastructure. All Terraform commands
should now work.

If you ever set or change modules or backend configuration for Terraform,
rerun this command to reinitialize your working directory. If you forget, other
commands will detect it and remind you to do so if necessary.
srinigps@BDC7-L-332CY3C:~/GPS/terraform/client$


Terraform issues:

srinigps@BDC7-L-332CY3C:~/GPS/terraform/client$ terraform plan
var.ec2_sg
  Enter a value: ^Z
[1]+  Stopped                 terraform plan
srinigps@BDC7-L-332CY3C:~/GPS/terraform/client$ terraform plan --var-file=variables.tfvars
╷
│ Error: Error acquiring the state lock
│
│ Error message: resource temporarily unavailable
│ Lock Info:
│   ID:        4b09ca7c-b00c-583b-c2a7-8b2dd3672d38
│   Path:      terraform.tfstate
│   Operation: OperationTypePlan
│   Who:       srinigps@BDC7-L-332CY3C
│   Version:   1.2.3
│   Created:   2025-07-07 04:05:56.709215939 +0000 UTC
│   Info:
│
│
│ Terraform acquires a state lock to protect the state from being written
│ by multiple users at the same time. Please resolve the issue above and try
│ again. For most commands, you can disable locking with the "-lock=false"
│ flag, but this is not recommended.
╵
srinigps@BDC7-L-332CY3C:~/GPS/terraform/client$

Terraform force-unlock <Lock-ID>
