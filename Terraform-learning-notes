Terraform init
	- Check the config file and initializes the working directory containing the .tf
	- Initialize the providers mentioned
	- Making use the plugins, downloads the plugin and install it (example - local plugin or aws plugins)
	- Terraform plugins are downloaded in ${working_directory}/.terraform/plugins/
	- The command can be run as many times as needed.

local_file provider example:

Main.tf
Resource "local_file" "pet"{
    filename = "/var/tmp/pets.txt"
    content = "we love pets"
}

We can have multiple providers in the same configuration file.

Local with random provider
Resource "local_file" "pet"{
    filename = "/var/tmp/pets.txt"
    content = "we love pets"
}

Resource "random_pet" "mypet"{
}

Providers with version constraints:

We can specify the providers with version constraints,

Terraform {
    required_providers {
         local = {
             source = "hashicorp/local"
             version = "1.4.0" ("!=2.0.0" | "< 1.4.0" | "> 1.1.0" | "> 1.2.0, < 2.0.0, != 1.4.0"| "~> 1.2")
         }
    }
}

Terraform show
	- Displays the configuration created by running the terraform show command
	- This command inspects the state file and display the resource created

Terraform plan
	- Creates the plan of infrastructure to be created from the tf files
	- Output to the .plan file
	- Terraform refresh=false --> do not refresh the state. Just go with the config details in tfstate file.

Terraform apply
	- Apply the plan

Any change in the tf file after the infra is created, the resource will be force replaces (forces replacement)

Tf files:
	- Main.tf: main configuration file containing resource definition
	- Variables.tf: contains variable declaration
	- Outputs.tf: contains outputs from resources
	- Provider.tf: contains provider information.

Variables in terraform:

Defined in variables.tf

Variables.tf
Variable "prefix" {
     default = ["Mr", "Mrs", "Sir"]
      type = list
}

Variable "length" {
     default = 2
     type = number
     description = ""
}

Main.tf
Resource "random_pet" "mypet"{
     prefix = var.prefix[0]
     length = var.length
}

Supported types:

string	
Number	
Bool	
Any	
List	
Map	
Object	
tuple	


If you want to use the output generated by one resource as input to other:

${random_pet.mypet.id} ---> Since random_pet returns the id of the pet created.

Resource dependencies:

Depends_on = []

Output variables:

Output pet-name {
     value = random_pet.mypet.id
     description = "record the value of random_pet generated"
}

	- After terraform apply, the output variables with value is printed on the console.
	- We can also see the output variables list with values using,
	Terraform output

Terraform state:

	- The state file created only after the apply is run atleast once.
	- since the state file contains the sensitive date, store it in secured locations - like S3.

Terraform commands

	- Terraform validate - validates the configuration
	- Terraform fmt - format the code
	- Terraform show --json
	- Terraform providers
	- Terraform output
	- Terraform refresh --> update the state file
	- Terraform graph
		○ Shows the graphical representation of the resources created
		○ Install graph (apt-get install graphviz -y)
		○ Terraform graph | dot -Tsvg > graph.svg
	
	
Terraform life cycle management:

Create_before_destroy: if set to true, new resource to be created first, then older one to be deleted.

Resource "local_file" "pet"{
    filename = "/var/tmp/pets.txt"
    content = "we love pets"

    lifecycle {
        create_before_destroy = true
    }
}

Prevent_destroy: prevents resource deletion when config is changed and terraform apply is run.
The resource can still be deleted if terraform destroy is used.

Resource "local_file" "pet"{
    filename = "/var/tmp/pets.txt"
    content = "we love pets"

    lifecycle {
        prevent_destroy = true
    }
}

Ignore_changes: accepts a list of valid attributes in the resource to ignore the changes made outside terraform (manually or cli)

Resource "aws_instance" "webserver" {
     ami = "ami---"
     instance_type = "t2.micro"
     tags = {
           Name = "ProjectA-webserver"
     }


    lifecycle {
        ignore_changes = [ tags/all ]
    }

}


Data Source:

Manage files created outside terraform.
Use keyword data

Resource "local_file" "pet"{
    filename = "/var/tmp/pets.txt"
    content = "we love pets"
}

Data "local_file" "dog" {
    filename = "/var/tmp/dogs.txt"
}

Here dogs.txt was created outside terraform using shell script. To manage it using terraform we use data source with keyword data. The dogs.txt will now be managed in the tfstate file.

Resource vs Datasource:
Resource	Datasource
Keyword: resource	Keyword: data
Creates, updates, destroys infra	Only reads infra
Also called managed resources	Also called data resources


Remote state and state locking:

If we have the state file locally, other users who work in the code will not have the latest state file with them which may cause conflicts. It's not good either to have the state file in git repo as git does not provide state locking, also every time user may not git pull, that means the users may not have the latest state file.

State locking is very important to avoid concurrency. Two users working on same code if the state is not locked, may lead to conflicts.


Terraform backend to specify the remote state location:

Terraform{
    backend "s3" {
         bucket = "<bucket-name>"
         key       = "<dir-name>"
         region  = "us-east-1"
         dynamodb_table = "state-locking"
    }
}

Manipulating terraform state:

This operation is strictly restricted. Do not use unless no other option.

Terraform state show aws_s3_bucket.finance

Other subcommands:

List
Mv
Rm
Pull
show


Terraform taint:

If you want to have the resource re-created, taint the resource. By tainting the resource, terraform will re-create the resource in the next apply.

To undo a taint, use untaint

Terraform logging:

To save the logs generated with apply command, use env variable TF_LOG_PATH.

Export TF_LOG_PATH=/tmp/terraform.log   ----> all the logs will be written to this file. To disable loggin,

Unset TF_LOG_PATH

Terraform import:

For the unmanaged resource of terraform (created outside terraform), we can use datasource . But this will still not have complete control on the resource. Like we cannot delete or update the resource. We need to use terraform import.

Terraform import <resource_type>.<resource_name> <attribute>

Terraform import aws_instance.webserver-2 i-xxxxxxxxxxxxxxxxxx

Error: Resource address "aws_instance.webserver-2" does not exist in the configuration.

Before importing it, we need to add a dummy resource in our configuration first.

Dummy resource block:
Resource "aws_instance" "webserver-2" {
}

Terraform import aws_instance.webserver-2 i-xxxxxxxxxxxxxxxxxx
Import will be successful now.

Now inspect the management console or the state file to add the attributes in the configuration file.


Terraform for-each:

Variables.tf
variable "users" {
    type = set(string)
}
variable "content" {
    default = "password: S3cr3tP@ssw0rd"
  
}

Main.tf
resource "local_file" "name" {
    filename = each.value
    sensitive_content = var.content
    for_each var.users
}


Terraform functions:

Toset(); Converts list to set - removes duplicates
Max()
Min()
Ciel() - rounds the decimal to highest (ciel(10.1) = 11)
Floor() - rounds the decimal to lowest (floor(10.9) = 10)

Split(seperator,string)
Lower()
Upper()
Title() --> convert first string to upper
Substr() --> 
Join(seperator,list)
Length() --> 
Index()
Element()
Contains()

Conditional expressions:

&& -> both should be true - result is true
||   -> either should be true - result is true
!      -> Not operator

Ifelse:
If <>
   then
      <>
   else
      <>
fi

Conditional operator:
Condition ? <true_val> : <false_val>

Terraform workspaces:




How to migrate tfstate files:
-------------------------------------

OK, I think I figured out how to do this (or at least, these steps seemed to work):
        • rename the current folder with the .tf files to something else (like folder.old)
        • use "terraform state pull" to get a local copy of the state for the current workspace (you need to repeat these steps for each workspace you want to migrate)
        • create a new folder with the original name and copy your code to it.
        • create a new workspace with the same name as the original.
        • modify the code for the remote backend to point to the new container (or whatever else you're changing about the name/location of the remote state).
        • run "terraform init" so it's pointing to the new remote backend.
        • use "terraform state push local state file" to push the exported state to the new backend.
I then used "terraform state list" and "terraform plan" in the new folder to sanity check that everything seemed to be there.



terraform {
  backend "s3" {
    bucket         = "srinitfstate493976-1"
    key            = "vpc.terraform.tfstate"
    region         = "us-east-1"
    dynamodb_table = "srinitfstate"
  }
}

Changed the backend config and run terraform init

[root@ip-172-31-51-130 tfscripts]# terraform init
Initializing modules...

Initializing the backend...
╷
│ Error: Backend configuration changed
│
│ A change in the backend configuration has been detected, which may require migrating existing state.
│
│ If you wish to attempt automatic migration of the state, use "terraform init -migrate-state".
│ If you wish to store the current configuration with no changes to the state, use "terraform init -reconfigure".
╵

[root@ip-172-31-51-130 tfscripts]#terraform init -migrate-state

Will automatically move the state file from prev backend to current backend


How to delete a specific vm created in a resource group having other vms? (Resource_type.name)
How to delete 3rd server only in the list of 5 servers created?

Creating 5 servers with different instance types - foreach and count - 
https://github.com/AKSarav/Terraform-Count-ForEach

Multiple subnets example:

https://developer.hashicorp.com/terraform/language/functions/flatten#flattening-nested-structures-for-for_each
